defmodule PgEx.Error do
  @moduledoc """
  Used to build an PgEx.Error based on various error conditions. There should
  be no need to call these functions from application code.
  """
  alias PgEx.Parser

  defstruct [
    # The error message received by the server. Nil in the case of a non-server-
    # generated error
    :pg,

    # The code received by the server. Nil in the case of a non-server-generated
    # error
    :code,

    # An error message, never nil.
    :message
  ]

  @typedoc """
  Errors returned by PgEx are always of type %PgEx.Error{}. The `message` field
  is never nil. However, the `pg` and `code` fields will always be `nil` for
  errors generated by the library itself and non-nil for errors generated by
  the database server.
  """
  @type t :: %__MODULE__{
    pg: nil | map,
    message: any,
    code: nil | pos_integer,
  }

  # 1 - Error messages returned by the database server.
  @doc false
  @spec build(any) :: t
  def build({?E, message}) do
    pg = parse_pg_error(message, [])
    %__MODULE__{
      pg: pg,
      code: pg[:code],
      message: pg[:message],
    }
  end

  @doc false
  # 2 - Some piece of code that returned an {:error, any}. So far, these most
  #     likely correspond to networking issues (:timeout, :closed, ...) on these
  #     socket we have open to  communicate with the server.
  def build({:error, message}) do
    %__MODULE__{message: message}
  end

  @doc false
  # 3 - An unexpected server response. For example, we sent a Bind message and
  #     only handle a BindComplete message. Anything else will end up here.
  #     We check for an Error (?E) response first and special handle that.
  #     These shouldn't happen and likely represent a bug in the driver.
  def build({type, _message}) when type in [65..128] do
    %__MODULE__{
      message: "unexpected response type (likely a bug in pgex, please report): #{<<type::utf8>>}"
    }
  end

  @doc false
  # 4 - Anything else.
  def build(unknown) do
    %__MODULE__{
      message: "unknown error: #{inspect unknown}"
    }
  end

  @fields %{
    ?S => :severity,
    ?V => :severity2,
    ?C => :code,
    ?M => :message,
    ?D => :detail,
    ?H => :hint,
    ?P => :position,
    ?p => :internal_position,
    ?W => :where,
    ?s => :schema,
    ?t => :table,
    ?c => :column,
    ?n => :constraint,
    ?F => :file,
    ?L => :line,
    ?R => :routine,
  }

  defp parse_pg_error(<<0>>, acc), do: acc

  for {field, name} <- @fields do
    defp parse_pg_error(<<unquote(field), rest::binary>>, acc) do
      {value, rest} = Parser.read_string(rest)
      parse_pg_error(rest, [{unquote(name), value} | acc])
    end
  end

  # if we get an error field with an unknown type prefix, use the type
  # itself as the key
  defp parse_pg_error(<<type, rest::binary>>, acc) do
    {value, rest} = Parser.read_string(rest)
    parse_pg_error(rest, [{<<type::utf8>>, value} | acc])
  end
end
